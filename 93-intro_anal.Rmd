```{r include=FALSE}
# Not sure why alignment was shifted back to left?
knitr::opts_chunk$set(tidy = FALSE, fig.align = "center")
```

# Intro to R using R Markdown {#rmdanal}

In this chapter, you'll see many of the ways that R stores objects and more
details on how you can use functions to solve problems in R.  You'll be
working with a common dataset derived from something that you likely have
encountered before:  the periodic table from chemistry.

## A beginning directory/file workflow

> "File organization and naming are powerful weapons against chaos." - Jenny Bryan

Something that is not frequently discussed when working with files and programming
languages like R is the importance of naming your files something relevantly and 
having organization of your files in folders.  You may be tempted to call a file 
`analysis.Rmd` but what happens when you need to change your analysis months from 
now and you've named many files for many different projects `analysis.Rmd` in many
different folders.  It's much better to give your future self a break and commit 
to concise naming strategies.

You can choose a variety of ways to name files.  These guidelines are what I try 
to follow:

1. Group similar style files into the same folder whenever possible.

    Try not to have one folder that contains all of the different types of files 
    you are working with.  It is much easier to find what you are looking for if 
    you put all of your `data` files in a `data` folder, all of your `figure` files
    in a `figure` folder, and so on.

    This rule can be broken if you only have one or two of each type.  It can be the
    case that too many folders can waste your time when a useful search for the
    appropriate file may be able to find your find faster than digging through a 
    complex hierarchy of directories.

2. Name your files consistently so that what the file contains can be easily 
identified from the name of your file, but be concise.

    Seeing `test1.Rmd` and `test2.Rmd` doesn't tell us much about what is actually
    in the files.  It's OK to create a temporary file or two if you don't think you
    will be using it going forward, but you should be in the habit of reviewing your
    work at the end of your session and naming files that we needed appropriately.  
    Something like `model_fit_sodium.Rmd` is so much better in the long-run.  
    Remember to think about your future self whenever you can, especially with 
    programming.  Be nice to yourself so that future self really appreciates past self.

3. Use an underscore to separate elements of the file name.

    The underscore `_` produces a visually appealing way for us to realize there is
    a separation between content.  You may be tempted to just use a space, but spaces
    cause problems in R and in other programming languages.  Some folks prefer to just
    change the case of the first letter of the word to bring attention.  Here are a few
    examples of file names.  You can be the judge as to what is most appealing to you:

    `barplot_weight_height.Rmd` vs `barplotWeightHeight.Rmd` vs (the worst) 
    `barplotweightheight.Rmd`

    Whatever you choose for style, be consistent and think about other users as you
    name your files.  If you were passed a smorgasbord of files that is a mess to
    deal with and hard to understand, you wouldn't like it, right?  Don't be that
    person to someone else (or yourself)!

## Using R with periodic table dataset

We now hop into the basics of working with a dataset in R.  We will also explore the
ways R stores data in **objects**, how to access specific elements in those objects,
and also how to use **functions**, which are one of the most useful pieces of R to
help with organization and clean code.

It is worthy to note that many of the functions here such as `table` and concepts like subsetting, indexing, and creating/modifying new variables can also be done using the great packages that Hadley Wickham has developed and in particular the `dplyr` package.  It is still important to get a sense for how R stores objects and how to interact with objects in the "old-school" way.  You'll still find some times where doing it this old way actually works just as nicely as the newer modern ways...but they are becoming fewer and fewer by the day.  Anyways, you'll hopefully be well-ready to hop into some statistical analyses or data tasks after you follow along with this introduction to R.

### Loading data from a file

One of the most common ways you'll want to work with data is by importing it from a
file.  A common file format that works nicely with R is the CSV (comma-seperated values)
file.  The following R commands first download the CSV file from the internet on my
webpage into the `periodic-table-data.csv` file on your computer, then reads in the
CSV stored, and then gives the name `periodic_table` to the data frame that stores
these values in R:

```{r load_elements}
download.file(url = "http://ismayc.github.io/periodic-table-data.csv", 
  destfile = "periodic-table-data.csv")
periodic_table <- read.csv("periodic-table-data.csv",
                           stringsAsFactors = FALSE)
```

We will be discussing both **strings** and **factors** in the data structures
section (Section \@ref(data-structures)) and why this additional parameter 
`stringsAsFactors` set to `FALSE` is recommended.

It's good practice to check out the data after you have loaded it in:

```{r eval=FALSE}
View(periodic_table)
```

The GIF below walks through downloading the CSV file and loading it into the
`periodic_table` data frame object.  In addition, it shows another way to view
dataframes that is built into RStudio without having to run the `View` function.
Note that a new R Markdown file is created here as well called `chemistry_example.Rmd`.
We are writing the commands directly into R chunks here, but you may find it nicer to
play around in your R Console sandbox first.

```{r loadchemdata, echo=FALSE, fig.cap="Viewing the periodic table data frame"}
knitr::include_graphics("gifs/chemistr_load.gif")
```


## Data structures

### Data frames

Data frames are by far the most common type of object you will work with in R.
This makes sense since R is a statistical computing language at its core, so
handling spreadsheet-like data is something it should be good at.  The `periodic_table`
data set is stored as a data frame.  As you can see there are many different types
of variables in this data set.  We can get a glimpse as to the types and some of the
values of the variables by using the `str` function:

```{r}
str(periodic_table)
```

Each of the names of the variables/columns in the data frame are listed immediately after
the `$`.  Then on each row of the `str` function call after the `:` we see what type of
variable it is.  For this `periodic_table` data set, we have four types:  `int`, `chr`,
`num`, and `logi`:

- `int` corresponds to integer values
- `chr` corresponds to character string values
- `num` corresponds to numeric (not necessarily integer) values
- `logi` corresponds to logical values (`TRUE` or `FALSE`)

### Vectors

Data frames are most commonly just many vectors put together into a single object.  Our
`periodic_table` data frame has each row correspond to a chemical element and each
column correspond to a different measurement or characteristic of that element.

There are many different ways to create a vector that stands on its own outside of a
data frame.

**Using the `c` function**

If you would like to list out many entries and put them into a vector object, you can
do so via the `c` function. If you enter `?c` in the R Console, you can gain information
about it.  The "c" stands for combine or concatenate.

Suppose we wanted to create a way to store four names:

```{r friendnames}
friend_names <- c("Bertha", "Herbert", "Alice", "Nathaniel")
friend_names
```

You can see when `friend_names` is outputted that there are four entries
to it.  This is vector is known as a **strings** vector since it contains
character strings.  You can check to see what type an object is by
using the `class` function:

```{r}
class(friend_names)
```

Next suppose we wanted to put the ages of our friends in another vector.
We can again use the `c` function:

```{r ages}
friend_ages <- c(25L, 37L, 22L, 30L)
friend_ages
class(friend_ages)
```

Note the use of the `L` value here.  This tells R that the numbers entered have
no decimal components.  If we didn't designate the `L` we can see that the values
are read in as `"numeric"` by default:

```{r}
ages_numeric <- c(25, 37, 22, 30)
class(ages_numeric)
```

There is not a huge difference in how these values are stored from a user's perspective,
but it is a good habit to specify what class your variables are whenever possible to help
with collaboration and documentation.

**Using the `seq` function**

The most likely way you will enter character values into a vector is via the `c` function.
Numeric values can be entered in a couple different ways.  You saw the first way using the 
`c` function above.  Since numbers have an ordering to them, we can also specify a sequence
of numbers with some starting value, ending value, and how much we'd like to increment each
step in the sequence:

```{r}
sequence_by_2 <- seq(from = 0L, to = 100L, by = 2L)
sequence_by_2
class(sequence_by_2)
```

You now might have a better sense to what the numbers in the `[ ]` before the output refer to.
This is done to help you keep track of where you are in the printing of the output.  So the first
element denoted by `[1]` is 0, the 18^th^ entry (`[18]`) is 34, and the 35^th^ entry (`[35]`) is 68.
This will serve as a nice introduction into indexing and subsetting in Section \@ref(index-sub).

We can also set the sequence to go by a negative number or a decimal value.  We will do both in
the next example.

```{r}
dec_frac_seq <- seq(from = 10, to = 3, by = -0.2)
dec_frac_seq
class(dec_frac_seq)
```

**Using the `:` operator**

A short-cut version of the `seq` version can be achieved using the `:` operator.  If we are
increasing values by 1 (or -1), we can use the `:` operator to build our vector:

```{r}
inc_seq <- 98:112
inc_seq
dec_seq <- 5:-5
dec_seq
```

**Combining vectors into data frames**

If you aren't reading in data from a file and you have some vectors of information
you'd like combined into a single data frame, you can use the `data.frame` function
to do so:

```{r friends}
friends <- data.frame(names = friend_names, 
                      ages = friend_ages,
                      stringsAsFactors = FALSE)
friends
```

Here we have created a `names` variable in the `friends` data frame that
corresponds to the values in the `friend_names` vector and similarly an
`ages` variable in `friends` that corresponds to the values in `friend_ages`.

### Factors

If we have a strings vector/variable that has some sort of natural ordering to it, it
frequently makes sense to convert that vector/variable into a **factor**.  The
factor will convert the strings to integers to keep track of which order you'd prefer
and also keep track of the original string values as well.

Looking over our `periodic_table` data frame again via `View(periodic_table)`, you
can see some good candidates for shifting from `chr` to `Factor`.  If you remember
your chemistry, you'll know that the natural ordering of the `block` variable is
`"s"`, `"p"`, `"d"`, and `"f"`.  

By default, R will organize character strings in alphabetical order.  To see this,
we'll introduce two new features:  the `table` function and the `$` operator.

```{r}
table(periodic_table$block)
```

We see here a count of the number of elements that appear in each block.  But as I said, the ordering is off.  You may remember the `$` as appearing before the variable names in the `str` function.  That wasn't a coincidence.  To access specific variables inside a data frame we can do so by entering the name of the data frame followed by `$` and lastly by the name of the variable.  (Note here that spaces in variable names will not work.  You'll learn that the hard way as I have more than likely.)

To convert `block` into a factor, we use the aptly named `factor` function:

```{r factor}
periodic_table$block <- factor(periodic_table$block,
                               levels = c("s", "p", "d", "f"))
```

```{r}
table(periodic_table$block)
```

You'll find that this is an easy way to organize your data whenever you'd like to summarize it or to plot it, but we'll save that discussion for a different time and a different book.

## Vectorized operations

R can work extremely quickly when handed a vector or a collection of vectors like a data frame.  Instead of walking through each element to perform an operation that we might need to do in other older programming languages, we can do something like this:

```{r}
five_years_older <- ages_numeric + 5L
five_years_older
```
Like that, we have ages that are five more than where we started.  This extends to adding two vectors together^[Vectors of the same size, of course...well, actually R has a way of dealing with vectors of different sizes and not giving errors, but let's ignore that for now.].  

## Indexing and subsetting {#index-sub}

So we have a big data frame of information about the periodic table, but what if we wanted to extract smaller pieces of the data frame.  You already saw that to focus on any specific variable we can use the `$` operator.




## Functions

- default arguments
- Why do some arguments require quotations and others don't?
